// Note: The Global Boolean AUTORUN (at the top of the file), when True will skip the 
// starting screen and immediatly play, also, upon "game-over" it will loop and run
// the game infinitly. 

// [ ALL OF THIS IS IMPLEMENTED IN MY GITHUB FLAPPY.PY FILE ]
// [ ALL CSV FILES ARE LOCATED WITHIN OUTPUT_CSV FILE ]
// [ EXPORTCVS() IS CALLED WITHIN THE SHOWGAMEOVERSCREEN() FUNCTION ]

// Code for Generating CSV

// Outputs are recorded in a list, 'Records'
// Data is pushed to Records around line 300 - the same place as the print to console calls - using the following code: 

           time = datetime.datetime.now().strftime('%M:%S')
            Records.append(
                [{'player_x': playerx,
                  'player_y': playery,
                  'pipe_lowy': lowerPipes[0]['y'],
                  'pipe_upy': upperPipes[0]['y'],
                  'flapped': playerFlapped,
                  'dx_pipe': upperPipes[0]['x'],
                  'input_x': inputx,
                  'input_y': inputy,
                  'time': time}]
            )

// The following are the Utility Functions for CSV export and calculation:

// Flatterns the list of list.
def flattenList(x):
    if isinstance(x, dict):
        return [x]
    elif isinstance(x, collections.Iterable) :
        return [a for i in x for a in flattenList(i)]
    else:
        return [x]

// Insures all data is consistent in length, if not, adds 'na' 
// to end until all lists are of equal length to the longst list - this is 
// important for CSV formatting.
def padlists(lists):
    longest = 0
    for i in lists:
        if len(i) > longest:
            longest = len(i)

    for li in lists:
        while len(li) <= longest:
            li.append('na')
    return lists

// Manually calculates when the players jumps, or flaps.
def calculateJumps(y):
    i = 1
    ls =[]
    while i < len(y):
        if abs(y[i-1] - y[i]) > 7:
            ls.append("JUMPED")
            i+=1
        else:
            ls.append("____")
            i+=1

    while len(ls)<len(y):
        ls.append("____")
    while len(ls) > len(y):
        ls.pop()

    return ls

// export function
// seperates and organizes each data category
// creates CSV file.

def exportCSV():
    flat_records = flattenList(Records)
    date = datetime.datetime.now().strftime("%H-%M-%S")
    filename = "DATA_"+date+".CSV"
    csv_dir = "/Users/HarlowAdmin/PycharmProjects/Flappy-Bird-Neural-Net/output_csv/"+filename

    px = []
    py = []
    lowy = []
    upy = []
    flapped = []
    dxpipe = []
    inx = []
    iny = []
    time = []

    for data in flat_records:
        px.append(data['player_x'])
        py.append(data['player_y'])
        lowy.append(data['pipe_lowy'])
        upy.append(data['pipe_upy'])
        dxpipe.append(data['dx_pipe'])
        inx.append(data['input_x'])
        iny.append(data['input_y'])
        time.append(data['time'])
    flapped = calculateJumps(py)
    supv_datset = [[px] + [py] + [lowy] + [upy] + [flapped] + [dxpipe] + [inx] + [iny] + [time]]
    supv_datset = padlists(supv_datset)

    csvfile = open(csv_dir, 'w')
    with csvfile:
        myFields = ['POS_X', 'POS_Y',
                    'FLAPPED',
                    'DIST_TO_PIPE',
                    'LOW_PIPE_Y',
                    'TOP_PIPE_Y',
                    'INPUT_X', 'INPUT_Y',
                    'TIME']
        writer = csv.DictWriter(csvfile, fieldnames=myFields)
        writer.writeheader()
        i = 0
        while i < len(py):
            writer.writerow({'POS_X': px[i], 'POS_Y': py[i],
                             'FLAPPED': flapped[i],
                             'DIST_TO_PIPE': dxpipe[i],
                             'LOW_PIPE_Y': lowy[i],
                             'TOP_PIPE_Y': upy[i],
                             'INPUT_X': inx[i], 'INPUT_Y': iny[i],
                             'TIME': time[i]})
            i += 1

    csvfile.close()
